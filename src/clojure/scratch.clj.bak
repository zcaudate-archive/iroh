
(comment
  (origins (:delegate (.? String "charAt" :#)))
  (seq (.getInterfaces String))
  (.? CharSequence)
  (def direct-handle (.? java.lang.invoke.DirectMethodHandle "new" :#))
  (def method-type (.? java.lang.invoke.MethodType "makeImpl" :#))
  (def member-from-method (.? java.lang.invoke.MemberName "new"
                              [java.lang.reflect.Method] :#))

  (def obj-member-name
    (member-from-method (:delegate (.? Object "toString" :#))))
  (def obj-type (method-type String (class-array Class [Object]) true))
  (def obj-handle (direct-handle obj-type obj-member-name false Object))
  (invoke obj-handle 1) ;;=> "java.lang.Long@1"
  (invoke obj-handle 100) ;;=> "java.lang.Long@64"


  (def member-name (.? java.lang.invoke.MemberName "new" [Class String java.lang.invoke.MethodType] :#))
  (def str-type (method-type String (class-array Class [String]) true))
  (def str-member-name
    (member-from-method (:delegate (.? String "toString" :#))))
  (def str-handle (direct-handle str-type str-member-name false String))

  (defn invoke [^java.lang.invoke.MethodHandle handle & args]
    (.invokeWithArguments handle (object-array args)))

  (invoke obj-handle "oeuoeu")
  (invoke str-handle "oeuoeueo")

  (java.lang.invoke.MethodType.)

  (>pst)
  (keys (object-lookup (test.A.)))

  ((-> (instance-lookup sun.reflect.ReflectionFactory)
        (get "langReflectAccess")
        (:fields)))


  (.$ toString)

  (.$ without {:a 1} :a)

  (get (get-element-lookup (.* {:a 1})) "toString")
  (def handles-lu (java.lang.invoke.MethodHandles/lookup))
  (.invoke (.unreflect handles-lu (:delegate (.? Object "equals" :#)))
           (object-array ["1"]))

  (def a 1)
  (>pst)
  ((.* a #{String}) a)
  ((.* a #{Number} "shortValue" :#))
  ((.? Integer  2 #(= "parseInt" (:name %))) "14" 10)
  ((.? String "toCharArray" :#) "Oeuoeu")

  (def acquire-accessor (.? java.lang.reflect.Method #"acquire" :#))
  (.invoke (acquire-accessor (:delegate (.? test.A #"to" :#)))
           (test.B.) (object-array 0))

  (reimport 'im.chit.iroh.Util
            'test.A
            'test.B)
  (Util/invokeMethod (:delegate (.? test.B #"to" :#)) test. (list (test.B.)))
  (.findSpecial (java.lang.invoke.MethodHandles/lookup) A "toString" )

  (.invokeWithArguments
   (.findSpecial (java.lang.invoke.MethodHandles/lookup)
                 A "toString" (java.lang.invoke.MethodType/methodType String)
                 Object)
   (to-array (test.B.)))

  (element-params (to-element (vec (.? String "new"))))

  (>pst)
  (>var create-string [String new])
  (>ns test.string String)
  (>var create-string [String new 3])

  (list)
  (>refresh)
  (def to-char-ar
    ray (.? String "toCharArray" :#))

  (to-char-array "oeuoeu")
  ((.* "oueu" "toString" [String] :#) "oeuoeu")
  ((.* "oueu" "toString" [Object] :#) "oeuoeu")

  ((.? sun.reflect.NativeMethodAccessorImpl "invoke0" :#)
   (:delegate (.? test.A #"to" :#))
   (cast test.A (test.B.))
   (object-array []))


  (defn invoke-handle [^java.lang.invoke.MethodHandle handle args]
    (.invokeWithArguments handle (object-array args)))

  (invoke-handle (:handle (.? Object #"to" :#)) ["oeuo"])

  (macroexpand-1 (>ns test.string String identity []))

  (test.string/value "oeuoeu")
  ((.? Object #"to" :#) (test.A.))
  ((.? test.B #"to" :#) (test.B.))
  ((.? test.A #"to" :#) (test.B.))
  ((.? test.A #"to" :#) (test.A.)))

(comment "iroh.core"
  (>pst)
  (keys (object-lookup (test.A.)))
  (refine-lookup (object-lookup (test.A.)))



  ((-> (instance-lookup sun.reflect.ReflectionFactory)
        (get "langReflectAccess")
        (:fields)))

  (def a 1)
  ((.* a :private :#) a)
  ((.* a #{Number} "shortValue"))
  ((.? Integer  2 #(= "parseInt" (:name %))) "14" 10)
  ((.? String "toCharArray" :#) "Oeuoeu")

  (def acquire-accessor (.? java.lang.reflect.Method #"acquire" :#))
  (.invoke (acquire-accessor (:delegate (.? test.A #"to" :#)))
           (test.B.) (object-array 0))
  ()

  (def to-char-array (.? String "toCharArray" :#))

  (to-char-array "oeuoeu")

  ((.? sun.reflect.NativeMethodAccessorImpl "invoke0" :#)
   (:delegate (.? test.A #"to" :#))
   (cast test.A (test.B.))
   (object-array []))

  (instance-options )
  ((.? test.B #"to" :#) (test.A.))
  ((.? test.B #"to" :#) (test.B.))
  ((.? test.A #"to" :#) (test.B.))
  ((.? test.A #"to" :#) (test.A.))
  )



(comment "iroh.element.method"
  (use 'iroh.core)
  (>refresh)
  ((.? Object "new" :#))
  (.newInstance (:delegate (second (.? Long "new"))) (object-array ["oeuoeu"]))
  (box-args (second (.? Long "new")) ["oeuoeu"])
  (box-args (second (.? Long "new")) ["oeuoeu"])

  ((second (.? Long "new")) "234234")
  ((.? Long :method :private :#) 1 "o")
  ((.? Long :method :private :#))
  ((.? Class :method :instance "isInterface" :#) 1)
  (>pst)
  )



(comment "From iroh.element.multi"
  (use 'iroh.core)
  (>refresh)
  (.? String :instance :field)
  ((to-element [(.? String :instance :field "hash" :#)]) "oueou" 1 2)
  ((to-element [(.? String :instance :field "hash" :#)]) "oueou")

  ((.? String :instance :field "hash" :#) "ouou") 1
  (-> ((.? String :instance :field "value" :#) "ouou")
      seq)

  (def a "OUOEUOU")
  ((.? String :instance :field "value" :#) a (char-array [\a]))

  (>pst)

  (apply (.? Object "wait" :#))
  (apply (.? Object "toString" :#) [1 2])
  (.? clojure.lang.IFn #"apply")
  (>source apply)
  )
  








;;(element-meta (to-element (.getDeclaredField A "finalA")))
;;((.? java.util.Date :field :static #"serial" :#) 123123)
;;((to-element (.getDeclaredField java.util.Date "serialVersionUID")) 10)

(comment "iroh.element.field"
  (import 'test.A 'test.B)
  (def a (A.))
  (def b (B.))
  ;;(.finalA b)

  (.get (:delegate (to-element (.getDeclaredField A "finalA"))) a)
  (.get (:delegate (to-element (.getDeclaredField A "finalA"))) b)

  ;;(.toString a)
  ;;((to-element (.getDeclaredField A "finalA")) a) ",.p,.p,.p,.p"

  (comment
    (use 'iroh.core)
    (>pst)
    (>refresh)
    (.* b)
    ((.? Object "new" :#))
    ((.? Long :field #"MAX" :#) 1)
    (.isInstance Number 1)
    (.getClass 1)
    )
)
